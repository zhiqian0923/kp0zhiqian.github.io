---
layout: post
title: C语言的数据类型
---

# 基本数据类型

- `char` : 需要1bytes的内存来存储单个字符。实际上存储的也是整数。
- `int` : 用来存储整数。
- `float` : 用来存储单精度数。
- `double` : 用来存储双精度数。

# `int`和`char`
`int`用于存储整数，`char`用于存储字符或者标点（但本质上也是存储的整数）
## 修饰关键字
- `unsigned`: 表示无符号的数，比如`unsigned int`就是指这个数据类型是无符号的，也就是说这个类型所表示的所有数不包括负整数。修饰了`unsigned`的`int`类型，在存储时，全部的位都用来存放数字，而没有修饰`unsigned`的`int`，默认就是`signed`类型的`int`。这样的整数，在存储时第一位则用来存放符号。
- `long`: 长整数，用来存储更大的整数，默认是有符号类型。
    > 除此之外，还有`unsigned long`, `long long`, `unsigned long long`类型，用来存储更大的数的场景，不过多数时候编译器一般会自行使用最合适的类型进行编译。
- `short`: 短整数，用来存储更小的整数，以节省存储空间，默认也是有符号类型。
    > 除此之外，也有`unsigned short`的使用方式。

## 不同类型的选择

### 使用不同的类型意味着什么？
实际上，在C语言中，并没有规定什么数据类型一定占用多少存储空间。因为计算机本身的位数可能是不一样的，所以C语言只是规定了**short的存储空间不能多于int，long占用的存储空间不能少于int**。

> 所以short占用的空间可能可以等于int，而long占用的空间可能也可以等于int。

### 怎么选择int的不同类型？
在计数场景下，首先考虑`unsigned`类型。因为计数场景下，我们并不需要负数，而且在同样的存储空间下可以表示更大的数。
如果一个数超过了`int`的取值范围，则考虑使用`long`类型，但是要注意，在那些`long`类型比`int`类型占用的空间大的机器上，使用`long`类型可能会拖🈵️运行速度。如果在`long`和`int`类型占用空间相同的机器上编码，则优先考虑使用long类型，以保证同样的程序移植到其他`int`小于`long`的机器上时能依然正常运行。


## `Char`和字符常量
在C语言中，单引号内部的会被编译器认为是字符常量，编译器在发现字符常量时，会将其转换成对应的代码值。

### 非打印字符

#### 如何使用非打印字符？
1. 使用ASCII码来表示那些非打印字符
2. 使用转义序列来表示非打印字符

#### 转义序列列表
|  转义序列   | 描述  |
|  ----  | ----  |
|   \\'	|  单引号 |
| \\" |	双引号 |
| \\? |	问号 |
| \\ |	反斜杠 |
| \\a |	响铃 |
| \\b |	退格 |
| \\f |	换页 |
| \\n |	换行 |
| \\r |	回车 |
| \\t |	水平制表符 |
| \\v |	垂直制表符 |
| \\0oo | 八进制值，oo必须是有效的8进制数，即每个o可以表示0～7中的一个 |
| \\xhh | 十六进制值，hh必须是有效的16进制数，即每个h可以表示0～f中的一个 |

#### 如何在转移序列和ASCII码之间做选择？
如果非要在两者之间做选择的话，那么请选择转移序列，因为不仅好记，而且可移植性更好。

## 存储与打印

将数据通过指定数据类型的方式存储到计算机中后，我们还需要将数据取出来。在将数据取出来时，我们可以将同样的数据通过不同的 format specifier 打印出来。

# `float`浮点数

## 浮点数的类型
- `float`: C语言规定，`float`类型必须最少能表示6位有效数字（包括小数点前边的数字），而取值范围至少是10<sup>-37</sup> ~ 10 <sup>37</sup>。
- `double`: 与`float`的取取值范围相同，但有效数字至少能表示10位，而一般情况下，double占用64位，而float占用32位。
- `long double`: 满足更高的精度要求，不过C语言只是保证不少与double的精度。

## 浮点计算默认方式
默认情况下，编译器会假定浮点型的常量是double类型的精度，在计算之后，如果需要的是float型，则将结果截断成float类型的宽度。但这种默认的情况，会在某种情况下拖满程序运行速度。

```c
float some; 
some = 4.0 * 2.0;
```
**问：这时候怎么办呢？**

在这种时候，我们就可以通过手动设置常量的类型，来覆盖掉默认的设置。

如果我们想将默认的double覆盖成float型：
```c
float some;
some = 4.0F * 2.0F;
```
如果我们想将默认的double覆盖成long double：
```c
float some;
some = 4.0L * 2.0L
```

> C99标准添加了一种新的浮点型常量的格——用16进制：在16进制数前加上0x（16进制前缀），用p和P分别代表e和E，用2的幂代替10的幂（也叫[p计数法]())

## 打印浮点数

| 转换说明 | 描述  |
|  ----  | ----  |
| %f | 十进制计数法 |
| %e | 指数计数法| 


## 浮点值的上溢和下溢

在计算后的浮点值超过系统最大的float类型值时，我们称这种情况为上溢，在发生了上溢时，C语言会给这个float类型赋上一个无穷大的特定值，打印出来会是**inf**或者**infinity**。

在计算后的浮点值的精度已经低于最大可能的精度时，我们称这种情况为下溢，在发生了下溢时，C语言会舍弃一位的尾数。
>不用担心，C语言已经提供了用于检查计算时候会产生下溢的函数。

# 查看系统当前的类型大小

通过c语言内置的sizeof运算，sizeof会以字节为单位返回指定类型的大小。

sizeof返回的数据类型是size_t，在printf中，我们需要使用%zd来打印它。

```c
printf("%zd", sizeof(int))